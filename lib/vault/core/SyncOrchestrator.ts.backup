"use client";

import { ModeController } from '../../system/ModeController';
import { HydrationController } from '../hydration/HydrationController';
import { IntegrityService } from '../services/IntegrityService';
import { MaintenanceService } from '../services/MaintenanceService';
import { identityManager } from '../core/IdentityManager';
import { telemetry } from '../Telemetry';
import { db } from '@/lib/offlineDB';
import { PushService } from '../services/PushService';
import { PullService } from '../services/PullService';
import { RiskManager, LicenseVault } from '../security';
import { getVaultStore } from '../store/storeHelper';
import { SyncGuard } from '../guards/SyncGuard';
import { GuardResult } from '../types/SyncTypes';

/**
 * üöÄ REFACTORED SYNC ORCHESTRATOR - Clean Architecture Implementation
 * 
 * This is the new, clean orchestrator that follows SOLID principles:
 * - Single Responsibility: Each service has one job
 * - Open/Closed: Extensible without modification
 * - Liskov Substitution: Services are interchangeable
 * - Interface Segregation: Focused interfaces
 * - Dependency Inversion: Depends on abstractions
 * 
 * Replaces the 1500+ line God Object with focused services.
 */

export class SyncOrchestratorRefactored {
  private pushService: PushService;
  private pullService: PullService;
  private hydrationController: HydrationController;
  private integrityService: IntegrityService;
  private maintenanceService: MaintenanceService;
  private channel: BroadcastChannel | null = null;
  private userId: string = '';
  private isInitialized = false;
  private isInitializing = false;
  private static isInitializing = false;
  private static initializationPromise: Promise<void> | null = null;
  private tabId = Math.random().toString(36).substr(2, 9); // üÜï SOURCE ID GUARD
  private lastRefreshTime: number = 0; // üÜï Prevent refreshBooks spam
  // üÜï DEBOUNCE STATE: Prevent rapid-fire sync triggers
  private syncDebounceTimeout: NodeJS.Timeout | null = null;
  private pendingSyncOperations: Array<{ timestamp: number; source: string }> = [];

  /**
   * üîÑ UNIFIED SERVICE PROPAGATION
   * Centralized userId setting for all services after successful validation
   */
  private syncServiceIdentities(userId: string): void {
    this.pushService.setUserId(userId);
    this.pullService.setUserId(userId);
    this.hydrationController.setUserId(userId);
    this.integrityService.setUserId(userId);
  }

  constructor() {
    this.pushService = new PushService();
    this.pullService = new PullService();
    this.hydrationController = HydrationController.getInstance();
    this.integrityService = new IntegrityService();
    this.maintenanceService = new MaintenanceService();

    // üîí SYNCHRONIZED INIT: Get userId immediately to prevent race condition
    this.userId = identityManager.getUserId() || '';
    console.log('üîÑ [ORCHESTRATOR] Initialized with userId:', this.userId);

    this.syncServiceIdentities(this.userId);

    this.init();

    // üÜï REACTIVE SYNC: Listen for vault-updated events
    if (typeof window !== 'undefined') {
      window.addEventListener('vault-updated', (event: any) => {
        const source = event.detail?.source || 'unknown';
        const origin = event.detail?.origin || 'unknown';

        // üõ°Ô∏è IGNORE BACKGROUND SYNC: Only trigger for local user actions
        if ((origin === 'local-mutation' || origin === 'batch-mutation') && source === 'HydrationController') {
          // üÜï PREVENT REFRESH SPAM: Only allow refreshBooks once per second
          const now = Date.now();
          if (now - this.lastRefreshTime < 1000) {
            console.log('üõ°Ô∏è [ORCHESTRATOR] RefreshBooks spam prevented, skipping');
            return;
          }
          this.lastRefreshTime = now;

          console.log('üì° [ORCHESTRATOR] Vault update detected, queuing for debounced sync');

          // üéØ ADD TO PENDING QUEUE: Track operation
          this.pendingSyncOperations.push({ 
            timestamp: Date.now(), 
            source: 'batch-mutation' 
          });

          // üïê DEBOUNCE: Clear existing timeout and set new 500ms delay
          if (this.syncDebounceTimeout) {
            clearTimeout(this.syncDebounceTimeout);
          }

          this.syncDebounceTimeout = setTimeout(() => {
            console.log(`üöÄ [ORCHESTRATOR] Debounced sync triggered for ${this.pendingSyncOperations.length} operations`);
            this.pendingSyncOperations = []; // Clear queue
            this.triggerSync();
          }, 500); // üéØ INCREASED from 100ms to 500ms
        }
      });
    }
  }
  /**
   * üõ°Ô∏è GET CHANNEL - Self-healing channel getter
   */
  private getChannel(): BroadcastChannel {
    if (!this.channel) {
      this.channel = new BroadcastChannel('vault_global_sync');
      console.log('üõ°Ô∏è [ORCHESTRATOR] Created new BroadcastChannel');

      // Attach: refresh listener whenever a new channel is created
      this.channel.onmessage = (event) => {
        // üõ°Ô∏è SELF-LOOP GUARD: Ignore messages from this tab
        if (event.data?.sourceTabId === this.tabId) {
          console.log('üõ°Ô∏è [ORCHESTRATOR] Ignoring self-broadcast message');
          return;
        }

        // üõ°Ô∏è SYNC GUARD: Ignore broadcast if sync is already running
        if (this.isInitializing) {
          console.log('üõ°Ô∏è [ORCHESTRATOR] Ignoring broadcast - sync already running');
          return;
        }

        if (event.data?.type === 'FORCE_REFRESH') {
          console.log('üì° [ORCHESTRATOR] Cross-tab refresh signal received');
          this.notifyUI('CrossTab');
        }
      };
    }

    return this.channel;
  }
  /**

   * INITIALIZATION

   */

  private async init(): Promise<void> {

    if (typeof window !== 'undefined') {

      // ÔøΩÔ∏è FORCE FRESH START: Reset bootStatus to ensure skeleton appears

      const store = getVaultStore();

      store.setBootStatus('IDLE');

      

      // ÔøΩüïµÔ∏è‚Äç‚ôÇÔ∏è SECURITY CHECK: Time Tampering

      const isTampered = RiskManager.checkTimeTampering();

      if (isTampered) {

          console.error('üö® [SECURITY] Critical: Time tampering detected!');

          // Future: We can ban the user here. For now, just log.

      }



      // SELF-HEALING BROADCAST CHANNEL

      this.getChannel();

      

      // Identity management

      identityManager.subscribe(async (uid) => {

        console.log('[REFACTORED ORCHESTRATOR] Identity changed, initializing sequence');

        

        if (!uid) {

          this.userId = '';

          console.log('üîê [REFACTORED ORCHESTRATOR] User logged out, stopping services');

          this.cleanup();

          return;

        }

        

        this.userId = uid;

        

        // ÔøΩÔ∏è GLOBAL LOCK: Prevent multiple initialization sequences

        if (SyncOrchestratorRefactored.isInitializing) {

          console.log('ÔøΩ [ORCHESTRATOR] Already initializing, waiting...');

          return SyncOrchestratorRefactored.initializationPromise;

        }



        // ÔøΩÔ∏è SET GLOBAL LOCK

        SyncOrchestratorRefactored.isInitializing = true;

        SyncOrchestratorRefactored.initializationPromise = this.performGateBasedInitialization(uid);

        

        try {

          await SyncOrchestratorRefactored.initializationPromise;

        } finally {

          // üõ°Ô∏è RELEASE GLOBAL LOCK

          SyncOrchestratorRefactored.isInitializing = false;

          SyncOrchestratorRefactored.initializationPromise = null;

        }

      });

    }


    

    try {

      // üõ°Ô∏è DOUBLE-PULL PROTECTION: Check if pull is already in progress

      const pullStatus = this.pullService.getPullStatus();

      if (pullStatus.isPulling) {

        console.log('ÔøΩÔ∏è [ORCHESTRATOR] Pull already in progress, skipping...');

        return;

      }

      

      // üÜï SYNC GUARD: Centralized validation (VERBATIM replacement)
      const guardResult = await SyncGuard.validateSyncAccess({
        serviceName: 'SyncOrchestrator',
        onError: async (msg, details) => {
          console.warn(`üîí [SECURITY] Sync Blocked: ${msg}`);
          if (details && details.licenseAccess) {
            await telemetry.log({
              type: 'SECURITY',
              level: 'CRITICAL',
              message: `Lockdown triggered: INVALID_LICENSE - ${details.licenseAccess.reason}`,
              data: { reason: details.licenseAccess.reason, plan: details.licenseAccess.plan }
            });
          }
          getVaultStore().setSecurityLockdown(true);
        },
        returnError: () => undefined // Orchestrator returns void
      });
      if (!guardResult.valid) {
        console.warn('üîí [ORCHESTRATOR] Initialization blocked by security validation');
        return;
      }
      
      // üÜï GET VALIDATED USER ID FROM SYNC GUARD
      const userId = guardResult.userId || identityManager.getUserId();
      this.userId = userId || '';
      
      // üîÑ UNIFIED SERVICE PROPAGATION: Set userId for all services
      this.syncServiceIdentities(this.userId);
      
      // üÜï GATE 1: Wait for Identity - ROBUST ID RECOVERY
      const store = getVaultStore();
      store.setBootStatus('IDENTITY_WAIT');
      console.log('üîÑ [ORCHESTRATOR] Gate 1: Waiting for identity...');
      
      const identityUserId = await identityManager.waitForIdentity();
      console.log('‚úÖ [ORCHESTRATOR] Gate 1: Identity ready:', identityUserId);

      // üõ°Ô∏è GATE 2: Profile Sync + Lazy Fix

      store.setBootStatus('PROFILE_SYNC');

      console.log('üîÑ [ORCHESTRATOR] Gate 2: Checking user profile...');

      

      const user = await db.users.get(userId);

      if (!user || user.plan === undefined) {

        console.log('üîß [ORCHESTRATOR] User profile missing or incomplete, hydrating...');

        try {

          await this.hydrationController.hydrateUser(userId || '');

          

          // Apply Lazy Fix for legacy schema

          await db.users.update(userId || '', {

            plan: 'free',

            offlineExpiry: 0,

            riskScore: 0,

            receiptId: null

          });

          console.log('‚úÖ [ORCHESTRATOR] Gate 2: Profile hydrated and lazy fix applied');

        

        // üß† MODE CONTROLLER: Start network monitoring BEFORE Gate 3

        ModeController.start();

        console.log('üß† [ORCHESTRATOR] ModeController started - Network monitoring active');

        } catch (error) {

          // üß† SMART ERROR CLASSIFICATION: Distinguish recoverable from critical errors

          const errorStr = String(error);

          const is404Error = errorStr.includes('404') || 

                         errorStr.includes('Profile not found') ||

                         errorStr.includes('Failed to fetch user profile');

          const isNetworkError = errorStr.includes('fetch') || 

                               errorStr.includes('ECONNREFUSED') ||

                               errorStr.includes('NetworkError') ||

                               errorStr.includes('timeout');

          const isServerError = errorStr.includes('500') || 

                              errorStr.includes('Internal Server Error');

          

          if (is404Error) {

            // üõ°Ô∏è SOFT FAILURE: Allow Self-Healing without lockdown

            console.warn('‚ö†Ô∏è [ORCHESTRATOR] 404 detected, allowing Self-Healing without lockdown.');

            // Don't set lockdown, let default profile creation handle it

            return; // Continue to Gate 3

          }

          

          if (isNetworkError) {

            // üåê NETWORK FAILURE: Temporary issue, no lockdown needed

            console.warn('‚ö†Ô∏è [ORCHESTRATOR] Network error detected, will retry later.');

            return; // Continue to Gate 3, system will retry

          }

          

          // üõ°Ô∏è CRITICAL ERROR: Only lockdown for server errors or security issues

          const store = getVaultStore();

          store.setSecurityLockdown(true);

          store.setBootStatus('IDLE');

          store.setEmergencyHydrationStatus('failed');

          store.setSecurityErrorMessage('Critical error: Server error. Lockdown activated.');

          throw error; // Re-throw to trigger main catch block

        }

      }



      // üõ°Ô∏è GATE 3: Data Hydration

      store.setBootStatus('DATA_HYDRATION');

      console.log('üîÑ [ORCHESTRATOR] Gate 3: Starting sequential hydration...');

      

      // üåÅ BRIDGE THE IDENTITY GAP

      this.hydrationController.setUserId(userId); 

      getVaultStore().setSecurityLockdown(false); // Force clear old alarms

      

      const hydrationResult = await this.hydrationController.fullHydration(true);

      if (!hydrationResult.success) {

        console.warn('‚ö†Ô∏è [ORCHESTRATOR] Hydration failed, continuing boot with degraded functionality:', hydrationResult.error);

        // Don't crash - continue to next gate with degraded functionality

      } else {

        console.log('‚úÖ [ORCHESTRATOR] Gate 3: Data hydration complete');

      }



      // ÔøΩ RAM SYNCHRONIZATION: Pull all books and entries from Dexie into Zustand store

      console.log('üîÑ [ORCHESTRATOR] Synchronizing RAM from Dexie...');

      await store.refreshData();

      console.log('‚úÖ [ORCHESTRATOR] RAM synchronization complete');



      // ÔøΩüîÑ BACKGROUND PULL: Trigger data pull after Gate 3 hydration is complete

      if (process.env.NODE_ENV === 'development') {

        console.log('üîÑ [ORCHESTRATOR] Triggering background data pull...');

      }

      

      // üõ°Ô∏è SERVICE SETUP: Set user IDs BEFORE triggering pull (Critical Fix)

      this.pushService.setUserId(userId || '');

      this.pullService.setUserId(userId || '');

      this.integrityService.setUserId(userId || '');

      

      try {

        // üõ°Ô∏è DOUBLE-PULL PROTECTION: Check if pull is already in progress

        const pullStatus = this.pullService.getPullStatus();

        if (pullStatus.isPulling) {

          console.log('üõ°Ô∏è [ORCHESTRATOR] Pull already in progress, skipping...');

          return;

        }

        

        // üöÄ FLASH-PASS: Local data check for instant boot
        const localCount = await db.books.count();
        
        if (localCount > 0) {
          // ‚ö° RETURNING USER: Skip blocking pull, sync in background
          console.log('‚ö° [ORCHESTRATOR] Flash-Pass: Local data found, sync moved to background.');
          
          // Fire pull without await - non-blocking
          this.pullService.pullPendingData().then(pullResult => {
            if (pullResult && pullResult.success) {
              console.log('‚úÖ [ORCHESTRATOR] Background pull completed successfully');
              // üîÑ BACKGROUND UI REFRESH: Update UI silently after background sync
              store.refreshBooks('BACKGROUND_SYNC');
            } else {
              console.warn('‚ö†Ô∏è [ORCHESTRATOR] Background pull blocked/failed:', pullResult?.errors || 'Unknown security block');
            }
          }).catch(error => {
            console.warn('‚ö†Ô∏è [ORCHESTRATOR] Background pull failed, continuing boot:', error);
          });
        } else {
          // ‚è≥ FIRST-TIME USER: Wait for server pull
          console.log('‚è≥ [ORCHESTRATOR] Cold-Start: No local data, waiting for server pull.');
          
          const pullResult = await this.pullService.pullPendingData();

          if (pullResult && pullResult.success) {

            console.log('‚úÖ [ORCHESTRATOR] Background pull completed successfully');

          } else {

            console.warn('‚ö†Ô∏è [ORCHESTRATOR] Background pull blocked/failed:', pullResult?.errors || 'Unknown security block');

          }
        }

      } catch (error) {

        console.warn('‚ö†Ô∏è [ORCHESTRATOR] Background pull failed, continuing boot:', error);

        // Don't fail boot if pull fails, just continue

      }



      // üõ°Ô∏è GATE 4: Ready State

      console.log('üîÑ [ORCHESTRATOR] Final check: Waiting for books to hydrate...');

      await store.refreshBooks('INITIAL_BOOT'); // ‚úÖ AWAIT THE DATA

      store.setBootStatus('READY'); // ‚úÖ ONLY THEN SET READY

      

      // üîÑ INDEXEDDB SETTLE: Allow small delay for DB to settle

      await new Promise(resolve => setTimeout(resolve, 100));

      

      await store.refreshCounters();

      if (process.env.NODE_ENV === 'development') {

        console.log('üîÑ [ORCHESTRATOR] UI counters refreshed after hydration');

        console.log('‚úÖ [ORCHESTRATOR] Gate 4: Boot sequence complete - System READY');

      }



      // üõ°Ô∏è LOCKDOWN RESET: Ensure any old lockdown is cleared

      store.setSecurityLockdown(false);

      console.log('üîì [ORCHESTRATOR] Lockdown cleared - System fully operational');

      

      // üöÄ BRUTE-FORCE INTERACTION RESET: Clear any stuck overlays

      store.clearOverlays();

      document.body.style.pointerEvents = 'auto';

      console.log('üîì [ORCHESTRATOR] Interaction reset - All overlays cleared');

      

      // FORCE SPINNER KILL: Ensure UI is unlocked

      // Note: setIsLoading doesn't exist in store, but the UI spinner is controlled by bootStatus

      console.log(' [ORCHESTRATOR] Boot sequence complete - UI should be responsive');



      // SERVICE INTERLOCK: Only start services after boot is complete

      if (process.env.NODE_ENV === 'development') {

        console.log(' [ORCHESTRATOR] Starting background services...');

      }

      

      // üöÄ PARALLEL SERVICE STARTUP: Initialize all background services concurrently

      const serviceResults = await Promise.allSettled([

        this.integrityService.performIntegrityCheck(),

        this.checkAndResumeInterruptedSyncs(),

        this.maintenanceService.performGlobalCleanup(userId || '')

      ]);

      

      // Check for any service failures

      const failedServices = serviceResults.filter(result => result.status === 'rejected');

      if (failedServices.length > 0) {

        console.warn('‚ö†Ô∏è [ORCHESTRATOR] Some background services failed:', failedServices);

      }

      

      // Schedule integrity checks after initial check

      this.integrityService.scheduleIntegrityChecks();

      

      console.log('üèÅ [ORCHESTRATOR] All systems ready - Chain of Command complete');

      

    } catch (error) {

      console.error('‚ùå [ORCHESTRATOR] Gate-based initialization failed:', error);

      const store = getVaultStore();

      store.setBootStatus('IDLE');

      store.setEmergencyHydrationStatus('failed');

      store.setSecurityLockdown(true);

      store.setSecurityErrorMessage('Boot sequence failed. Please refresh the page.');

    }

  }
  /**

   * üë§ INITIALIZE FOR USER

   */

  async initializeForUser(userId: string): Promise<void> {

    // üõ°Ô∏è STATIC LOCK: Prevent multiple initialization sequences globally

    if (SyncOrchestratorRefactored.isInitializing) {

      console.log(`[LOCK] Already initializing for user: ${userId}, returning existing promise.`);

      return SyncOrchestratorRefactored.initializationPromise!;

    }

    // üõ°Ô∏è INITIALIZATION GUARD

    if (this.isInitialized || this.isInitializing) {

      console.log('üèÅ [ORCHESTRATOR] Already initialized or initializing, skipping...');

      return;

    }

  
    // üõ°Ô∏è SET STATIC LOCK

    SyncOrchestratorRefactored.isInitializing = true;

    SyncOrchestratorRefactored.initializationPromise = this.performInitializeForUser(userId);

    try {

      await SyncOrchestratorRefactored.initializationPromise;

    } finally {

      // üõ°Ô∏è RELEASE STATIC LOCK

      SyncOrchestratorRefactored.isInitializing = false;

      SyncOrchestratorRefactored.initializationPromise = null;

    }

  }
  private async performInitializeForUser(userId: string): Promise<void> {

    try {

      console.log('üèÅ [REFACTORED ORCHESTRATOR] Initializing for user:', userId);

      

      // Set user ID for all services

      this.pushService.setUserId(userId);

      this.hydrationController.setUserId(userId);

      this.integrityService.setUserId(userId);

      // üõ°Ô∏è STEP 1: Data Integrity Repair

      console.log('üèÅ [REFACTORED ORCHESTRATOR] Step 1: Data integrity repair');

      await this.integrityService.performIntegrityCheck();

      // ÔøΩÔ∏è STEP 2: Initial Hydration

      console.log('üèÅ [REFACTORED ORCHESTRATOR] Step 2: Initial hydration');

      // üõ°Ô∏è FINAL SECURITY CHECK: Abort if lockdown is active

      const { isSecurityLockdown } = getVaultStore();

      if (isSecurityLockdown) {

        console.log('üõ°Ô∏è [SECURITY] Hydration blocked - App in lockdown mode');

        return; // ‚õî STOP ALL INITIALIZATION

      }
      const hydrationResult = await this.hydrationController.fullHydration(true);

      

      if (!hydrationResult.success) {

        console.error('‚ùå [REFACTORED ORCHESTRATOR] Initial hydration failed:', hydrationResult.error);

        telemetry.log({

          type: 'ERROR',

          level: 'ERROR',

          message: 'Initial hydration failed',

          data: { error: hydrationResult.error, userId }

        });

        // üõ°Ô∏è CRITICAL FIX: Immediate abort on hydration failure

        const store = getVaultStore();

        store.setSecurityLockdown(true);

        store.setBootStatus('IDLE');

        store.setSecurityErrorMessage('Hydration failed. Security lockdown activated.');

        return; // ‚õî STOP ALL INITIALIZATION

      }

      // üîç STEP 3: Integrity Audit

      console.log('üèÅ [REFACTORED ORCHESTRATOR] Step 3: Integrity audit');

      await this.integrityService.performIntegrityCheck();

      // üîÑ STEP 4: Start Background Services

      console.log('üèÅ [REFACTORED ORCHESTRATOR] Step 4: Starting background services');

      this.integrityService.scheduleIntegrityChecks();

      // üîÑ AUTO-RESUME: Check for interrupted syncs

      console.log('üîÑ [REFACTORED ORCHESTRATOR] Step 5: Auto-resume check');

      await this.checkAndResumeInterruptedSyncs();

      

      // üßπ STEP 6: Global maintenance cleanup

      console.log('üßπ [REFACTORED ORCHESTRATOR] Step 6: Global maintenance cleanup');

      await this.maintenanceService.performGlobalCleanup(userId);

      

      this.isInitialized = true;

      console.log('üèÅ [REFACTORED ORCHESTRATOR] Initialization complete - All systems ready');
      // Notify UI

      this.notifyUI('SyncOrchestrator');

    } catch (error) {
      console.error('‚ùå [REFACTORED ORCHESTRATOR] Initialization failed:', error);
      telemetry.log({
        type: 'ERROR',
        level: 'ERROR',
        message: 'Orchestrator initialization failed',
        data: { error: String(error), userId }
      });
    } finally {
      this.isInitializing = false;
    }
  }
  /**

   * üîÑ AUTO-RESUME: Check for interrupted syncs and resume them

   */

  private async checkAndResumeInterruptedSyncs(): Promise<void> {
    try {
      console.log('üîÑ [REFACTORED ORCHESTRATOR] Checking for interrupted syncs...');

      // Check for unsynced books

      const unsyncedBooks = await db.books.where('synced').equals(0).toArray();
      const unsyncedEntries = await db.entries.where('synced').equals(0).toArray();
      const totalUnsynced = unsyncedBooks.length + unsyncedEntries.length;

      if (totalUnsynced > 0) {
        console.log(`üîÑ [REFACTORED ORCHESTRATOR] Found ${totalUnsynced} unsynced items, resuming sync...`);
        console.log(`üìö Books: ${unsyncedBooks.length}, üìù Entries: ${unsyncedEntries.length}`);
        // Trigger automatic sync to resume interrupted operations

        const result = await this.pushService.pushPendingData();

        if (result.success) {
          console.log('‚úÖ [REFACTORED ORCHESTRATOR] Auto-resume sync completed successfully');
        } else {
          console.error('‚ùå [REFACTORED ORCHESTRATOR] Auto-resume sync failed:', result.errors);
        }
      } else {
        console.log('‚úÖ [REFACTORED ORCHESTRATOR] No interrupted syncs found');
      }
      
    } catch (error) {
      console.error('‚ùå [REFACTORED ORCHESTRATOR] Auto-resume check failed:', error);
    }
  }


  public async getSystemRiskStatus(): Promise<{
    systemHealth: 'HEALTHY' | 'WARNING' | 'CRITICAL';
    highRiskCount: number;

  }> {
    // Mocking logic or real integrity check
    return { systemHealth: 'HEALTHY' as const, highRiskCount: 0 };
  }
  /**

   * ÔøΩ GET SYSTEM RISK STATUS (V6.4)

   * Provides admin dashboard with real-time risk analytics

   */

  static async getSystemRiskStatus(): Promise<{
    highRiskCount: number;
    riskDistribution: { low: number; medium: number; high: number; critical: number };
    systemHealth: 'HEALTHY' | 'WARNING' | 'CRITICAL';
  }> {
    try {
      const [highRiskCount, riskDistribution] = await Promise.all([
        RiskManager.getHighRiskUserCount(),
        RiskManager.getRiskDistribution()
      ]);
      const systemHealth = highRiskCount > 100 ? 'CRITICAL' : 
                       highRiskCount > 50 ? 'WARNING' : 'HEALTHY';
      console.log('üìä [ADMIN] System risk status calculated:', {
        highRiskCount,
        riskDistribution,
        systemHealth
      });

      return {
        highRiskCount,
        riskDistribution,
        systemHealth
      };     
    } catch (error) {
      console.error('üîí [ADMIN] Failed to get system risk status:', error);
      return {
        highRiskCount: 0,
        riskDistribution: { low: 0, medium: 0, high: 0, critical: 0 },
        systemHealth: 'CRITICAL'
      };
    }
  }


  /**

   * üöÄ TRIGGER SYNC - Main sync orchestration method

   */

  async triggerSync(): Promise<void> {
    try {
      console.log('üöÄ [ORCHESTRATOR] Triggering sync sequence...');

      // üÜï SYNC GUARD: Centralized validation (VERBATIM replacement)

      const guardResult = await SyncGuard.validateSyncAccess({
        serviceName: 'SyncOrchestrator',
        onError: async (msg, details) => {
          console.warn(`üîí [SECURITY] Sync Blocked: ${msg}`);
          if (details && details.licenseAccess) {
            await telemetry.log({
              type: 'SECURITY',
              level: 'CRITICAL',
              message: `Lockdown triggered: INVALID_LICENSE - ${details.licenseAccess.reason}`,
              data: { reason: details.licenseAccess.reason, plan: details.licenseAccess.plan }
            });
          }
          getVaultStore().setSecurityLockdown(true);
        },
        returnError: () => undefined // Orchestrator returns void
      });
      if (!guardResult.valid) return;

      // üîÑ STEP 3: Trigger fresh sync

      await this.handleManualSyncFlow();     
    } catch (error) {
      console.error('‚ùå [REFACTORED ORCHESTRATOR] Manual sync failed:', error);
      telemetry.log({
        type: 'ERROR',
        level: 'ERROR',
        message: 'Manual sync failed',
        data: { error: String(error), userId: this.userId }
      });
    }
  }

  /*** üîÑ HANDLE MANUAL SYNC FLOW - Sequential sync enforcement */

  private async handleManualSyncFlow(): Promise<void> {

    try {

      console.log('üîÑ [ORCHESTRATOR] Starting sequential sync flow...');

      // Trigger manual sync from store

      const { triggerManualSync } = getVaultStore();

      await triggerManualSync();
      
      // üîÑ SEQUENTIAL SYNC ENFORCEMENT: Pull -> Check Conflicts -> Push
      console.log('üì• [ORCHESTRATOR] Step 1: Pull pending data...');
      const pullResult = await this.pullService.pullPendingData();
      
      console.log('üîç [ORCHESTRATOR] Step 2: Check for conflicts...');
      const integrityResult = await this.integrityService.validateFinancialChecksumsPublic();
      if (integrityResult.tamperingDetected) {
        console.warn('‚ö†Ô∏è [ORCHESTRATOR] Financial tampering detected during sync');
      }
      
      console.log('üì§ [ORCHESTRATOR] Step 3: Push pending data...');
      const pushResult = await this.pushService.pushPendingData();
      
      // Update sync progress in store
      const { setSyncProgress } = getVaultStore();
      const totalProcessed = (pullResult.itemsProcessed || 0) + (pushResult.itemsProcessed || 0);
      
      setSyncProgress({
        total: totalProcessed,
        processed: totalProcessed,
        percentage: 100,
        eta: 0
      });
      
      console.log('‚úÖ [ORCHESTRATOR] Sequential sync completed successfully');
      
      // Notify UI of completion
      this.notifyUI('HydrationService');
      
    } catch (error) {
      console.error('‚ùå [ORCHESTRATOR] Sequential sync flow failed:', error);
      telemetry.log({
        type: 'ERROR',
        level: 'ERROR',
        message: 'Sequential sync flow failed',
        data: { error: String(error), userId: this.userId }
      });
    }
  }

  /**
   * üì° NOTIFY UI - Origin-aware event dispatching
   */
  private notifyUI(origin?: string): void {
    if (typeof window !== 'undefined') {
      // ‚úÖ DISPATCH WITH tabId TO PREVENT SELF-LOOP
      window.dispatchEvent(new CustomEvent('vault-updated', { 
        detail: { 
          source: origin || 'SyncOrchestrator',
          origin: origin || 'SyncOrchestrator',
          tabId: this.tabId // CRITICAL: Identify the sender
        } 
      }));
      
      // Only broadcast to other tabs if not self-originated
      if (origin !== 'UI_REFRESH') {
        this.getChannel().postMessage({ 
          type: 'FORCE_REFRESH',
          source: 'SyncOrchestrator',
          origin: origin || 'SyncOrchestrator',
          sourceTabId: this.tabId // ‚úÖ SOURCE ID GUARD
        });
      }
    }
  }

  /**
   * üéØ HYDRATE SINGLE ITEM - Image sniper system support
   */
  async hydrateSingleItem(type: 'BOOK' | 'ENTRY', id: string): Promise<{ success: boolean; error?: string }> {
    try {
      console.log(`üéØ [ORCHESTRATOR] Hydrating single ${type} for ID: ${id}`);
      
      // Delegate to hydration controller
      const result = await this.hydrationController.hydrateSingleItem(type, id);
      
      if (result.success) {
        console.log(`‚úÖ [ORCHESTRATOR] Successfully hydrated ${type} ${id}`);
        // Notify UI of the update
        this.notifyUI('HydrationService');
      }
      
      return result;
      
    } catch (error) {
      console.error(`‚ùå [ORCHESTRATOR] Hydrate single item failed for ${type} ${id}:`, error);
      return { success: false, error: String(error) };
    }
  }

  /**
   * üßπ CLEANUP: Prevent memory leaks
   */
  private cleanup(): void {
    // Clear debounce timeout
    if (this.syncDebounceTimeout) {
      clearTimeout(this.syncDebounceTimeout);
      this.syncDebounceTimeout = null;
    }
    
    // Clear pending operations
    this.pendingSyncOperations = [];
    
    // Close broadcast channel
    if (this.channel) {
      this.channel.close();
      this.channel = null;
    }
    
    console.log('üßπ [ORCHESTRATOR] Cleanup completed');
  }

  /**
   * üîê LOGOUT - Clean up on user logout
   */
  logout(): void {
    console.log('üîê [REFACTORED ORCHESTRATOR] User logout, cleaning up...');
    this.cleanup();
    
    // üõ°Ô∏è V5.5 SECURITY: Clear user profile to prevent next login bypass
    db.users.clear().then(() => {
      console.log('üßπ [ORCHESTRATOR] User profile cleared from Dexie');
    }).catch((error: any) => {
      console.error('‚ùå [ORCHESTRATOR] Failed to clear user profile:', error);
    });
  }

}

// üöÄ EXPORT SINGLETON INSTANCE

export const orchestrator = new SyncOrchestratorRefactored();

